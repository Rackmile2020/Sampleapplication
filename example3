import { Injectable } from '@angular/core';
import { Router, NavigationStart } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class BackDetectorService {
  private backNavSubject = new BehaviorSubject<boolean>(false);
  public backNav$ = this.backNavSubject.asObservable();

  private urlHistory: string[] = [];
  private currentIndex = -1;

  constructor(private router: Router) {
    this.router.events
      .pipe(filter(e => e instanceof NavigationStart))
      .subscribe((event: NavigationStart & { navigationTrigger?: string }) => {
        const trigger = event.navigationTrigger;
        const currentUrl = event.url;

        // Initialize history on first navigation or reload
        if (this.currentIndex === -1) {
          this.urlHistory.push(currentUrl);
          this.currentIndex = 0;
          this.backNavSubject.next(false);
          return;
        }

        if (trigger === 'popstate') {
          // Back/forward navigation
          let existingIndex = this.urlHistory.indexOf(currentUrl);

          // If the URL is not in stack (deep link), push it
          if (existingIndex === -1) {
            this.urlHistory.push(currentUrl);
            existingIndex = this.urlHistory.length - 1;
          }

          if (existingIndex < this.currentIndex) {
            // ðŸ”¹ Back detected
            this.backNavSubject.next(true);
            console.log('â¬…ï¸ Browser BACK detected:', currentUrl);
          } else {
            // Forward or same
            this.backNavSubject.next(false);
          }

          this.currentIndex = existingIndex;
        } else {
          // Normal navigation (router.navigate, click, etc.)
          if (this.currentIndex < this.urlHistory.length - 1) {
            // Remove forward history
            this.urlHistory = this.urlHistory.slice(0, this.currentIndex + 1);
          }

          // Avoid duplicates
          if (this.urlHistory[this.currentIndex] !== currentUrl) {
            this.urlHistory.push(currentUrl);
            this.currentIndex = this.urlHistory.length - 1;
          }

          this.backNavSubject.next(false);
        }
      });
  }

  public isBackNavigation(): boolean {
    return this.backNavSubject.getValue();
  }

  public getPreviousUrl(): string | null {
    return this.currentIndex > 0 ? this.urlHistory[this.currentIndex - 1] : null;
  }

  public getCurrentUrl(): string | null {
    return this.currentIndex >= 0 ? this.urlHistory[this.currentIndex] : null;
  }
}
