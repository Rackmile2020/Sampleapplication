import { Injectable, Renderer2, RendererFactory2 } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class FocusTrapService {
  private focusableEls: HTMLElement[] = [];
  public activeElementBeforeTrap: HTMLElement | null = null;
  private cleanupListener: (() => void) | null = null;
  private renderer: Renderer2;

  constructor(rendererFactory: RendererFactory2) {
    this.renderer = rendererFactory.createRenderer(null, null);
  }

  trapFocus(container: HTMLElement, onEscape?: () => void) {
    this.activeElementBeforeTrap = document.activeElement as HTMLElement;

    if (!container.hasAttribute('tabindex')) container.setAttribute('tabindex', '-1');
    container.focus();

    this.focusableEls = Array.from(
      container.querySelectorAll<HTMLElement>(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      )
    );

    this.cleanupListener = this.renderer.listen(container, 'keydown', (event: KeyboardEvent) => {
      if (event.key === 'Tab') this.handleTab(event);
      if (event.key === 'Escape' && onEscape) onEscape();
    });
  }

  private handleTab(event: KeyboardEvent) {
    const first = this.focusableEls[0];
    const last = this.focusableEls[this.focusableEls.length - 1];

    if (event.shiftKey && document.activeElement === first) {
      event.preventDefault();
      last.focus();
    } else if (!event.shiftKey && document.activeElement === last) {
      event.preventDefault();
      first.focus();
    }
  }

  releaseFocus() {
    if (this.cleanupListener) {
      this.cleanupListener();
      this.cleanupListener = null;
    }
    if (this.activeElementBeforeTrap) this.activeElementBeforeTrap.focus();
    this.focusableEls = [];
    this.activeElementBeforeTrap = null;
  }
}
///////////////////////////////////////////////////////////////
import { Injectable, Injector, ApplicationRef, ComponentRef, Type, EnvironmentInjector, createComponent } from '@angular/core';
import { Subject, Subscription } from 'rxjs';
import { DialogComponent, DialogComponentBase } from './dialog.component';
import { FocusTrapService } from './focus-trap.service';

export class DialogRef<C = any, R = any> {
  private afterClosedSubject = new Subject<R | undefined>();

  constructor(
    public readonly id: string,
    private componentRef: ComponentRef<any>,
    private appRef: ApplicationRef,
    private focusTrap: FocusTrapService
  ) {}

  afterClosed() {
    return this.afterClosedSubject.asObservable();
  }

  close(result?: R) {
    this.afterClosedSubject.next(result);
    this.afterClosedSubject.complete();

    if (this.componentRef?.location.nativeElement) {
      this.componentRef.location.nativeElement.remove();
      const backdrop = document.querySelector('.modal-backdrop');
      if (backdrop) backdrop.remove();

      if (this.appRef && this.componentRef?.hostView) {
        this.appRef.detachView(this.componentRef.hostView);
      }

      this.componentRef.destroy();

      this.focusTrap.releaseFocus();

      document.body.classList.remove('modal-open');
      document.body.style.overflow = '';
      document.body.style.paddingRight = '';
    }
  }
}

@Injectable({ providedIn: 'root' })
export class MycoverageRealignDialogService {
  private activeDialogs = new Map<string, { componentRef: ComponentRef<any>; subscription: Subscription }>();

  constructor(
    private injector: Injector,
    private appRef: ApplicationRef,
    private environmentInjector: EnvironmentInjector,
    private focusTrap: FocusTrapService
  ) {}

  open<C = any, R = any, T extends DialogComponentBase<C, R> = DialogComponentBase<C, R>>(
    component: Type<T>,
    config?: C,
    dialogId?: string
  ): DialogRef<C, R> {
    const id = dialogId || Symbol().toString();

    if (this.activeDialogs.has(id)) this.close(id);

    setTimeout(() => {
      document.body.classList.add('modal-open');
      document.body.style.overflow = 'hidden';
      document.body.style.paddingRight = '0';
    }, 0);

    const componentRef = createComponent(component, {
      environmentInjector: this.environmentInjector,
      elementInjector: this.injector,
    });

    componentRef.instance.config = config;

    // Add backdrop
    const backdrop = document.createElement('div');
    backdrop.className = 'modal-backdrop fade show';
    document.body.appendChild(backdrop);

    document.body.appendChild(componentRef.location.nativeElement);
    this.appRef.attachView(componentRef.hostView);

    const dialogRef = new DialogRef<C, R>(id, componentRef, this.appRef, this.focusTrap);

    let subscription: Subscription | undefined;
    if (componentRef.instance.closeEvent) {
      subscription = componentRef.instance.closeEvent.subscribe((result?: R) => dialogRef.close(result));
    }

    this.activeDialogs.set(id, { componentRef, subscription: subscription || new Subscription() });

    // Trap focus inside dialog
    const dialogEl = componentRef.location.nativeElement.querySelector('.dialog');
    if (dialogEl) this.focusTrap.trapFocus(dialogEl, () => dialogRef.close());

    return dialogRef;
  }

  close(dialogId: string) {
    const dialog = this.activeDialogs.get(dialogId);
    if (dialog) {
      dialog.subscription.unsubscribe();
      dialog.componentRef.destroy();
      this.activeDialogs.delete(dialogId);
    }
  }

  closeAll() {
    Array.from(this.activeDialogs.keys()).forEach((id) => this.close(id));
  }
}
