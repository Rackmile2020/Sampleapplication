/*
Assuming Angular 19+ with standalone components and signals if needed. Here's a simplified version:
*/

// 1. search.service.ts
@Injectable({ providedIn: 'root' })
export class SearchService {
  private matches: HTMLElement[] = [];
  private currentIndex = signal(0);

  matches$ = toSignal(fromEvent(document, 'highlight-updated').pipe(
    map(() => this.matches.length)
  ));

  setMatches(elements: HTMLElement[]) {
    this.matches = elements;
    this.currentIndex.set(0);
    this.scrollToCurrent();
    document.dispatchEvent(new CustomEvent('highlight-updated'));
  }

  navigateNext() {
    if (!this.matches.length) return;
    this.currentIndex.set((this.currentIndex() + 1) % this.matches.length);
    this.scrollToCurrent();
  }

  navigatePrev() {
    if (!this.matches.length) return;
    this.currentIndex.set((this.currentIndex() - 1 + this.matches.length) % this.matches.length);
    this.scrollToCurrent();
  }

  scrollToCurrent() {
    const el = this.matches[this.currentIndex()];
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  getCurrentIndex(): Signal<number> {
    return this.currentIndex;
  }
}

// 2. search-bar.component.ts
@Component({
  selector: 'app-search-bar',
  standalone: true,
  imports: [CommonModule],
  template: `
    <input [(ngModel)]="query" (input)="onSearch()" />
    <button (click)="prev()">⬆</button>
    <button (click)="next()">⬇</button>
    <span>{{ currentIndex() + 1 }} / {{ totalMatches() }}</span>
    <button (click)="clear()">❌</button>
  `
})
export class SearchBarComponent {
  query = '';
  currentIndex = this.searchService.getCurrentIndex();
  totalMatches = this.searchService.matches$;

  constructor(private searchService: SearchService) {}

  onSearch() {
    const elements = Array.from(document.querySelectorAll('[data-searchable]'));
    const matches: HTMLElement[] = [];
    elements.forEach(el => {
      const html = el.innerHTML.replace(
        /<mark class="highlight">(.*?)<\/mark>/g,
        '$1'
      );
      el.innerHTML = html;
      if (this.query && el.textContent?.toLowerCase().includes(this.query.toLowerCase())) {
        const regex = new RegExp(`(${this.query})`, 'gi');
        el.innerHTML = html.replace(regex, '<mark class="highlight">$1</mark>');
        matches.push(el);
      }
    });

    const allAccordions = Array.from(document.querySelectorAll('app-accordion'));
    allAccordions.forEach(a => a.setAttribute('data-open', 'false'));
    matches.forEach(el => {
      const parentAccordion = el.closest('app-accordion');
      if (parentAccordion) parentAccordion.setAttribute('data-open', 'true');
    });

    this.searchService.setMatches(matches);
  }

  next() {
    this.searchService.navigateNext();
  }

  prev() {
    this.searchService.navigatePrev();
  }

  clear() {
    this.query = '';
    this.onSearch();
  }
}

// 3. accordion.component.ts
@Component({
  selector: 'app-accordion',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div (click)="toggle()" class="header">{{ title }}</div>
    <div class="body" [hidden]="!isOpen">
      <ng-content></ng-content>
    </div>
  `,
  host: {
    '[attr.data-open]': 'isOpen',
  },
  styles: [`
    .highlight { background: yellow; }
    .header { cursor: pointer; font-weight: bold; }
  `]
})
export class AccordionComponent implements OnInit {
  @Input() title = '';
  isOpen = false;

  ngOnInit() {
    const observer = new MutationObserver(() => {
      const attr = (document.querySelector(`[data-open][title='${this.title}']`)?.getAttribute('data-open'));
      this.isOpen = attr === 'true';
    });
    observer.observe(document.documentElement, { attributes: true, subtree: true });
  }

  toggle() {
    this.isOpen = !this.isOpen;
  }
}

// 4. component-a/b/c.ts - reuse AccordionComponent
@Component({
  selector: 'app-component-a',
  standalone: true,
  imports: [CommonModule, AccordionComponent],
  template: `
    <app-accordion title="Item A1">
      <div data-searchable>Angular framework is awesome.</div>
    </app-accordion>
    <app-accordion title="Item A2">
      <div data-searchable>Reusable components are key.</div>
    </app-accordion>
  `
})
export class ComponentA {}

// Repeat for B and C with unique content

// 5. app.component.ts
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [SearchBarComponent, ComponentA, ComponentB, ComponentC],
  template: `
    <app-search-bar />
    <app-component-a />
    <app-component-b />
    <app-component-c />
  `
})
export class AppComponent {}

/*
✅ Global search across all accordions
✅ Highlights and counts all matches
✅ Navigation through matches with ⬆/⬇
✅ Only matching accordions are expanded
✅ Manual accordion click also works
*/
