import { Injectable, Injector } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { filter } from 'rxjs/operators';
import { loadRemoteModule } from '@angular-architects/module-federation';

@Injectable({ providedIn: 'root' })
export class DataBridgeService {
  private parentService: any;
  private cache = new Map<string, BehaviorSubject<any>>();
  private calledTriggers = new Set<string>();

  constructor(private injector: Injector) {}

  /** Load parent service only once */
  async init() {
    if (this.parentService) return;

    const m = await loadRemoteModule({
      type: 'module',
      remoteEntry: 'http://localhost:4200/remoteEntry.js', // Parent's remoteEntry
      exposedModule: './ShareStoreDataService'
    });

    const serviceClass = m.ShareStoreDataService;
    this.parentService = this.injector.get(serviceClass);
  }

  /** Call any method in parent service */
  call(methodName: string, ...args: any[]) {
    return this.parentService?.[methodName]?.(...args);
  }

  /** Call a method only once for the same args */
  callOnce(methodName: string, ...args: any[]) {
    const key = `${methodName}:${JSON.stringify(args)}`;
    if (this.calledTriggers.has(key)) return;
    this.calledTriggers.add(key);
    return this.parentService?.[methodName]?.(...args);
  }

  /** Subscribe to an observable method and cache per args */
  stream(methodName: string, ...args: any[]): Observable<any> {
    const key = `${methodName}:${JSON.stringify(args)}`;
    if (!this.cache.has(key)) {
      const subj = new BehaviorSubject<any>(null);
      this.parentService[methodName](...args)
        .pipe(filter(v => v !== null && v !== undefined)) // skip empty
        .subscribe((data: any) => subj.next(data));
      this.cache.set(key, subj);
    }
    return this.cache.get(key)!.asObservable();
  }

  /**
   * Subscribe to a stream and call a trigger (both with optional args) only once
   * 
   * Usage:
   *   autoOnce('streamMethod', 'triggerMethod', cb)
   *   autoOnce('streamMethod', ['arg1'], 'triggerMethod', ['arg2'], cb)
   */
  autoOnce(
    streamMethod: string,
    streamArgsOrTriggerMethod: string | any[],
    triggerMethodOrCallback: string | ((data: any) => void),
    triggerArgsOrCallback?: any[] | ((data: any) => void),
    callback?: (data: any) => void
  ) {
    let streamArgs: any[] = [];
    let triggerMethod: string;
    let triggerArgs: any[] = [];
    let cb: (data: any) => void;

    // No args version
    if (typeof streamArgsOrTriggerMethod === 'string' && typeof triggerMethodOrCallback === 'function') {
      triggerMethod = streamArgsOrTriggerMethod;
      cb = triggerMethodOrCallback;
    }
    // With args version
    else if (Array.isArray(streamArgsOrTriggerMethod) && typeof triggerMethodOrCallback === 'string') {
      streamArgs = streamArgsOrTriggerMethod;
      triggerMethod = triggerMethodOrCallback;

      if (typeof triggerArgsOrCallback === 'function') {
        cb = triggerArgsOrCallback;
      } else {
        triggerArgs = triggerArgsOrCallback as any[];
        cb = callback!;
      }
    } else {
      throw new Error('Invalid autoOnce arguments');
    }

    this.stream(streamMethod, ...streamArgs).subscribe(cb);
    this.callOnce(triggerMethod, ...triggerArgs);
  }
}
