autoOnce(
  streamMethod: string,
  streamArgsOrTriggerMethod: string | any[],
  triggerMethodOrCallback: string | ((data: any) => void),
  triggerArgsOrCallback?: any[] | ((data: any) => void),
  callback?: (data: any) => void
) {
  let streamArgs: any[] = [];
  let triggerMethod: string;
  let triggerArgs: any[] = [];
  let cb: (data: any) => void;

  if (typeof streamArgsOrTriggerMethod === 'string' && typeof triggerMethodOrCallback === 'function') {
    triggerMethod = streamArgsOrTriggerMethod;
    cb = triggerMethodOrCallback;
  } else if (Array.isArray(streamArgsOrTriggerMethod) && typeof triggerMethodOrCallback === 'string') {
    streamArgs = streamArgsOrTriggerMethod;
    triggerMethod = triggerMethodOrCallback;
    if (typeof triggerArgsOrCallback === 'function') {
      cb = triggerArgsOrCallback;
    } else {
      triggerArgs = triggerArgsOrCallback as any[] ?? [];
      cb = callback!;
    }
  } else {
    throw new Error('Invalid autoOnce arguments');
  }

  const freshEveryTime = streamArgs[streamArgs.length - 1] === true;

  if (freshEveryTime) {
    const result = this.call(streamMethod, ...streamArgs);
    if (result instanceof Observable) {
      result.pipe(first()).subscribe(cb);
    } else {
      cb(result);
    }
    this.callOnce(triggerMethod, ...triggerArgs);
  } else {
    // subscribe ONLY to first emission after trigger
    this.stream(streamMethod, ...streamArgs).pipe(first()).subscribe(cb);
    this.callOnce(triggerMethod, ...triggerArgs);
  }
}
